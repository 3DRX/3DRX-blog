---
title: "OS: Memory Management & Virtual Memory"
description: "操作系统内存管理"
pubDate: "12/31/2023"
updatedDate: "12/31/2023"
heroImage: ""
---

<!--toc:start-->
- [分配与管理](#分配与管理)
  - [连续分配](#连续分配)
  - [动态分区算法](#动态分区算法)
  - [非连续分配](#非连续分配)
    - [分页存储](#分页存储)
      - [页表](#页表)
      - [地址转换](#地址转换)
    - [引入快表 TLB 后的分页存储](#引入快表-tlb-后的分页存储)
    - [两级页表](#两级页表)
    - [分段存储](#分段存储)
    - [分段与分页对比](#分段与分页对比)
<!--toc:end-->

---

## 分配与管理

### 连续分配
- 单一连续分配
系统被分为系统区和用户区，同时只能由一道用户程序，其独占整用户区空间。
- 固定分区分配
类似上面的单一连续分配，只不过划分成了固定数量的几个分区。
- **动态分配**
不预先划分内存分区，而是在进程装入内存时，按照进程的大小动态地建立分区。
使用两种常见的数据结构实现
    - 空闲分区表：
    每个表项中包含分区号、大小、起始地址等信息
    - 空闲分区链：
    每个分区的起始部分和末尾分别设置双向的指针

碎片的概念
- 内部碎片：分配给了进程，但进程没有利用
- 外部碎片：剩余的没有被分配的连续空间太小，难以被利用

### 动态分区算法
- First Fit
- Best Fit
- Worst Fit
- Next Fit

### 非连续分配

#### 分页存储
将内存分为大小相等的 page，并进行从 0 开始的编号。

##### 页表
|页号|块号|
|-|-|
|0|3|
|1|6|
|...|...|

页表项的大小：round up 到整数倍字节（存放块号），页号不占空间，因为页表是个数组，
其下标就是页号。

##### 地址转换
对给定的逻辑地址 A
1. 确定逻辑地址 A 对应的页号 P（判断 P 是否越界，如果是，则抛出页错误中断）
2. 找到 P 号页面在内存中的起始地址（查页表得到页框号，在乘上页大小）
3. 确定逻辑地址 A 在页内的偏移量 W（看 A 的最后 n 位即可，n 取决于页面长度）
4. 则 A 的物理地址 = P 起始地址 + W

#### 引入快表 TLB 后的分页存储
TLB, translation lookaside buffer 是一种速度比内存快很多的高速缓存，
用来存放最近访问的页表项的副本，可以加速地址转换的速度。
在进程切换时，快表会被清空。

在查询页表前先访问 TLB，如果命中，则可直接获得物理地址，不需要查询页表。

这个地方容易出让算时间的题，注意有的系统支持快表慢表同时查，
计算快表没有命中的时间的方式会稍有不同。

#### 两级页表

单级页表的问题：
1. 页表需要连续存储（数组），其占用空间过大（多个连续的页框）。
2. 同时高频访问的通常只有个别页面，因此没有必要让整个页表都常住内存。

其中两级页表主要解决了第一个问题，第二个问题由虚拟内存解决。
解决方式：
1. 可以将页表进行分组，每个内存块恰好能放入一个分组。
2. 为这些离散分配的页表再建立一张页表，称为页目录表或外层页表或顶层页表。

这种模式下的地址转换流程为：
1. 按照地址结构将逻辑地址拆分成三部分：一级页号，二级页号，页内偏移量。
2. 从 PCB 中读取出页目录表起始地址，再根据一级页号查页目录表，找出下一级页表在
内存中的位置。
3. 根据二级页号查表，找到最终想访问的内存块号。
4. 结合页内偏移量得到物理地址。


> n 级页表的原理类似，从逻辑上可以不断增加页表层数。
如果没有 TLB，n 级页表查询过程中的访存次数是 n + 1 次。

#### 分段存储

#### 分段与分页对比

